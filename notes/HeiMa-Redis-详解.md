

# 高级篇

高级篇旨在解决日常使用或分布式情况下的Redis可能会出现的问题。如**数据丢失问题**、**并发能力问题**、**存储能力问题**、**故障恢复问题**等。

这些问题都已有**解决方案**，如：

1. 数据丢失问题：通过实现Redis数据的持久化解决
2. 并发能力问题：可以通过搭建主从集群，实现读写分离
3. 存储能力问题：搭建分片集群，利用插槽机制实现动态扩容
4. 故障恢复问题：利用Redis哨兵，实现健康检测和自动恢复

接下来我们将学习以上这些解决方案的具体实现。

 

## Redis持久化

能够解决Redis出现的数据丢失问题，共有两种持久化方案，分别为RDB和AOF。



### RDB

RDB全称Redis Database Backup file（Redis数据备份文件），也叫做Redis数据快照。简单说就是将Redis内存中所有数据全部记录到磁盘中，当Redis服务故障重启后，会从磁盘中读取对应快照文件，恢复数据。

RDB方式持久化有两种运行方式，一种是手动执行保存命令，由Redis主进程来执行RDB命令，由于Redis是单线程，因此会阻塞其它所有正在运行的命令，执行命令为 **save** 。

另一种也是手动执行保存命令，但Redis会开启一个子进程来执行RDB，因此不会影响其它命令的运行，执行命令为 **bgsave**。

Redis服务在正常停止服务前会自动执行一次 **RDB** 。并在保存在运行目录下，默认命名为dump.rdb文件。

假设Redis在持续运行一段时间后，没有对Redis执行手动保存命令，且Redis出现异常宕机，那么这些长时间以来在Redis中存储的数据就会丢失。因此为解决这个问题，就需要让Redis自动进行持久化，而Redis中就存在这种机制，即触发RDB的机制，相关配置可以在redis.conf文件中找到，格式如下：

```
#900秒内，如果至少1个key被修改，则触发bgsave，如果是save "" 则表示禁用RDB
save 900 1
save 300 10
save 660 10000
```

相关的其它RDB配置也可以在redis.conf文件中设置：

```
#是否压缩存储，建议不开启，压缩过程会消耗cpu，而磁盘相对更不值钱
rdbcompression yes

#RDB文件名称
dbfilename dump.rdb

#文件保存的路径目录
dir ./
```

然后再谈谈 **bgsave** 异步保存数据的过程，bgsave 不像 save 命令，直接阻塞Redis进程进行RDB持久化操作，bgsave命令只有 fork 主进程得到子进程这一段时间内才会阻塞Redis。bgsave 命令开始时会先 fork 主进程得到子进程，子进程**共享主进程的内存数据**。这里需要先了解操作系统的相关知识：进程是无法直接访问操作系统的物理内存，只能通过操作与物理内存存在映射的虚拟内存，而子进程得到的就是虚拟内存数据，然后子进程根据映射**获取对应的内存数据并写入新的RBD文件**，然后用**新RDB文件替换旧RDB文件**。子进程在进行RDB操作时，主进程只能通过 copy-on-write 技术对内存数据进行操作。

RDB是Redis默认的持久化方案，但RDB也有自己的局限性，如自动持久化可能导致数据丢失，并且 fork 子进程，压缩，写出RDB文件都比较耗时。



### AOF

AOF全称为Append Only File（追加文件），AOF可以解决RDB中出现的一些问题。AOF持久化方案不通过每次保存所有内存中的数据而实现持久化，而是通过记录每次的写操作来记录操作，因此AOF也可以看作是命令的日志文件。当Redis出现故障重启后，会通过从头执行AOF中记录的写命令来还原内存数据。

AOF默认是关闭的，需要在配置文件中手动开启：

```
# 是否开启AOF功能，默认是no
appendonly yes
# AOF文件的名称
appendfilename "appendonly.aof"
```

AOF执行保存命令的频率也可以在配置文件中配置：

```
# 表示每执行一次写命令，就将操作记录到AOF文件中（可靠性好，但开销太大）
appendfsync always
# 写命令执行完后先将操作放入AOF缓冲区，然后每隔一秒将缓冲区数据写入AOF文件，这是默认方案
appendsync everysec
# 写命令执行完后先将操作放入AOF缓冲区，然后由操作系统自己决定什么时候将缓冲区内容写到磁盘文件。（不推荐）
appendsync no
```

使用AOF需要禁用RDB，在redis.conf中将RDB的配置save改为：

```
#save 900 1
save ""
```

虽然使用AOF能够解决RDB的部分问题，但AOF也有自己的问题，如果set记录过多，那么AOF文件会很庞大，因此可以通过执行bgrewriteaof命令，让AOF文件执行重写功能，缩减AOF文件大小，该命令的执行与主进程是异步的。

bgrewriteaof：记录set key value的最后一次操作、整合多个set为mset。

Redis既提供了手动执行命令缩减AOF文件大小，也可以通过触发阈值自动重写AOF文件，相关配置在redis.conf中配置：

```
# AOF文件比上次文件 增长超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写
auto-aof-rewrite-min-size 64mb
```



### 比较

RDB和AOF各有各的优点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用。

|                |                     RDB                      |                           AOF                            |
| :------------: | :------------------------------------------: | :------------------------------------------------------: |
|   持久化方式   |             定时对整个内存做快照             |                   记录每一次执行的命令                   |
|   数据完整性   |          不完整，两次备份之间会丢失          |                 相对完整，取决于刷盘策略                 |
|    文件大小    |             会有压缩，文件体积小             |                  记录命令，文件体积很大                  |
|  宕机恢复速度  |                     很快                     |                            慢                            |
| 数据恢复优先级 |          低，因为数据完整性不如AOF           |                  高，因为数据完整性更高                  |
|  系统资源占用  |            高，大量CPU和内存消耗             | 低，主要是磁盘IO资源，但AOF重写时会占用大量CPU和内存资源 |
|    使用场景    | 可以容忍数分钟的数据丢失，追求更快的启动速度 |                   对数据安全性要求较高                   |



## 主从

单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就要搭建主从集群，实现读写分离。





# 原理篇

